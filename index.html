<!DOCTYPE html>

<html>
<head>
    <title>RoTH Tetraeder Seed Ceremony</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; }
        #ui { 
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); color: white; padding: 25px; 
            border-radius: 15px; border: 1px solid rgba(255,255,255,0.1);
            max-width: 350px;
        }
        .vertex { 
            padding: 10px; margin: 8px 0; border-radius: 8px; 
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        .vertex:hover { background: rgba(255,255,255,0.1); transform: translateX(5px); }
        .vertex.selected { background: rgba(255,255,255,0.15); border-color: currentColor; font-weight: bold; }
        .vertex-Ïˆâ‚ { color: #FF6B6B; }
        .vertex-Ïˆâ‚‚ { color: #4ECDC4; }
        .vertex-Ïˆâ‚ƒ { color: #45B7D1; }
        .vertex-Ïˆâ‚„ { color: #FFE66D; }
        #coordinates { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin: 15px 0; font-family: monospace; }
        #passphrase { width: 100%; padding: 12px; margin: 10px 0; border: none; border-radius: 8px; background: rgba(255,255,255,0.1); color: white; }
        button { width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; }
        button:hover { background: #764ba2; }
        #seed-output { margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; word-break: break-all; font-family: monospace; font-size: 11px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <h2>ğŸ”º RoTH Seed Ceremony</h2>

```
    <div style="margin-bottom: 20px;">
        <strong>Velg ditt hjÃ¸rne:</strong>
        <div class="vertex vertex-Ïˆâ‚" onclick="selectVertex('Ïˆâ‚')">Ïˆâ‚: RÃ¸d (PrimÃ¦r)</div>
        <div class="vertex vertex-Ïˆâ‚‚" onclick="selectVertex('Ïˆâ‚‚')">Ïˆâ‚‚: BlÃ¥ (SekundÃ¦r)</div>
        <div class="vertex vertex-Ïˆâ‚ƒ" onclick="selectVertex('Ïˆâ‚ƒ')">Ïˆâ‚ƒ: GrÃ¸nn (TertiÃ¦r)</div>
        <div class="vertex vertex-Ïˆâ‚„" onclick="selectVertex('Ïˆâ‚„')">Ïˆâ‚„: Gul (KvaternÃ¦r)</div>
    </div>
    
    <div style="background: rgba(100,100,255,0.1); padding: 10px; border-radius: 8px; margin-bottom: 15px; font-size: 13px;">
        ğŸ’¡ <strong>Tips:</strong><br>
        â€¢ En finger: Roter X/Y<br>
        â€¢ To fingre: Vri Z-akse<br>
        â€¢ Velg hver farge og roter den!
    </div>
    
    <div id="coordinates">
        <div>ğŸ”„ <strong>Rotasjon:</strong> <span id="rot-x">0.0Â°</span>, <span id="rot-y">0.0Â°</span>, <span id="rot-z">0.0Â°</span></div>
        <div>ğŸ¯ <strong>HjÃ¸rne:</strong> <span id="current-vertex">Ïˆâ‚</span></div>
    </div>
    
    <input type="text" id="passphrase" placeholder="Skriv din passfrase her...">
    <button onclick="generateSeed()">ğŸ² Generer Seed</button>
    
    <div id="seed-output">
        <!-- Seed vil vises her -->
    </div>
</div>

<script>
    let scene, camera, renderer, tetrahedron;
    let selectedVertex = 'Ïˆâ‚';
    let vertexSpheres = [];
    
    // Lagre rotasjoner for hver farge
    let vertexRotations = {
        'Ïˆâ‚': { x: 0, y: 0, z: 0 },
        'Ïˆâ‚‚': { x: 0, y: 0, z: 0 },
        'Ïˆâ‚ƒ': { x: 0, y: 0, z: 0 },
        'Ïˆâ‚„': { x: 0, y: 0, z: 0 }
    };
    
    function init() {
        // Three.js setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        camera.position.z = 5;
        
        // Lighting
        scene.add(new THREE.AmbientLight(0x404040));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);
        
        createTetrahedron();
        setupTetrahedronDrag();
        selectVertex('Ïˆâ‚');
        animate();
    }
    
    function setupTetrahedronDrag() {
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let isShiftPressed = false;
        
        // Track shift key for Z-rotation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') isShiftPressed = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') isShiftPressed = false;
        });
        
        // Mouse events
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousPosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaMove = {
                x: e.clientX - previousPosition.x,
                y: e.clientY - previousPosition.y
            };
            
            if (isShiftPressed) {
                // Z-rotation when holding Shift
                tetrahedron.rotation.z += deltaMove.x * 0.01;
            } else {
                // Normal X and Y rotation
                tetrahedron.rotation.y += deltaMove.x * 0.01;
                tetrahedron.rotation.x += deltaMove.y * 0.01;
            }
            
            previousPosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        // Touch events for iPad/mobile
        let initialTouchDistance = 0;
        let initialRotationZ = 0;
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                // Single touch - normal rotation
                isDragging = true;
                const touch = e.touches[0];
                previousPosition = { x: touch.clientX, y: touch.clientY };
            } else if (e.touches.length === 2) {
                // Two finger touch - prepare for Z rotation
                isDragging = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const angle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                );
                initialRotationZ = angle;
            }
            e.preventDefault();
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                // Single touch - normal X/Y rotation
                const touch = e.touches[0];
                const deltaMove = {
                    x: touch.clientX - previousPosition.x,
                    y: touch.clientY - previousPosition.y
                };
                
                tetrahedron.rotation.y += deltaMove.x * 0.01;
                tetrahedron.rotation.x += deltaMove.y * 0.01;
                
                previousPosition = { x: touch.clientX, y: touch.clientY };
            } else if (e.touches.length === 2) {
                // Two finger twist - Z rotation
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const angle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                );
                const deltaAngle = angle - initialRotationZ;
                tetrahedron.rotation.z += deltaAngle;
                initialRotationZ = angle;
            }
            e.preventDefault();
        });
        
        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });
    }
    
    function createTetrahedron() {
        // Tetrahedron
        const geometry = new THREE.TetrahedronGeometry(2.5);
        const material = new THREE.MeshPhongMaterial({
            color: 0x444444, 
            transparent: true, 
            opacity: 0.2
        });
        tetrahedron = new THREE.Mesh(geometry, material);
        scene.add(tetrahedron);

        // Vertex spheres - VIKTIG: Legg kulene INNI tetraederet
        const sphereGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const vertices = [
            { pos: [1.3, 1.3, 1.3], color: 0xFF6B6B, id: 'Ïˆâ‚' },
            { pos: [1.3, -1.3, -1.3], color: 0x4ECDC4, id: 'Ïˆâ‚‚' },
            { pos: [-1.3, 1.3, -1.3], color: 0x45B7D1, id: 'Ïˆâ‚ƒ' },
            { pos: [-1.3, -1.3, 1.3], color: 0xFFE66D, id: 'Ïˆâ‚„' }
        ];

        vertices.forEach(vertex => {
            const material = new THREE.MeshPhongMaterial({ 
                color: vertex.color, 
                emissive: vertex.color, 
                emissiveIntensity: 0.3
            });
            const sphere = new THREE.Mesh(sphereGeometry, material);
            
            // VIKTIG: Sett posisjon RELATIVT til tetraederet
            sphere.position.set(vertex.pos[0], vertex.pos[1], vertex.pos[2]);
            sphere.userData = { id: vertex.id };
            
            // Legg kulen INNI tetraeder-mesh, ikke i scenen direkte
            tetrahedron.add(sphere);
            vertexSpheres.push(sphere);
        });

        // Wireframe
        const wireframe = new THREE.WireframeGeometry(geometry);
        const line = new THREE.LineSegments(wireframe);
        line.material.color.set(0x888888);
        line.material.transparent = true;
        line.material.opacity = 0.3;
        tetrahedron.add(line);
    }
    
    function selectVertex(vertexId) {
        // Lagre nÃ¥vÃ¦rende rotasjon fÃ¸r vi bytter
        if (tetrahedron) {
            vertexRotations[selectedVertex] = {
                x: tetrahedron.rotation.x,
                y: tetrahedron.rotation.y,
                z: tetrahedron.rotation.z
            };
        }
        
        selectedVertex = vertexId;
        
        // Last inn lagret rotasjon for ny valgt vertex
        if (tetrahedron) {
            tetrahedron.rotation.x = vertexRotations[vertexId].x;
            tetrahedron.rotation.y = vertexRotations[vertexId].y;
            tetrahedron.rotation.z = vertexRotations[vertexId].z;
        }
        
        // Update UI
        document.querySelectorAll('.vertex').forEach(el => {
            el.classList.toggle('selected', el.textContent.includes(vertexId));
        });
        
        document.getElementById('current-vertex').textContent = vertexId;
        
        // Visual feedback
        vertexSpheres.forEach(sphere => {
            const isSelected = sphere.userData.id === vertexId;
            sphere.material.emissiveIntensity = isSelected ? 0.8 : 0.3;
            sphere.scale.setScalar(isSelected ? 1.3 : 1.0);
        });
    }
    
    function generateSeed() {
        if (!tetrahedron) return;
        
        // Lagre nÃ¥vÃ¦rende rotasjon fÃ¸r vi genererer
        vertexRotations[selectedVertex] = {
            x: tetrahedron.rotation.x,
            y: tetrahedron.rotation.y,
            z: tetrahedron.rotation.z
        };
        
        const passphrase = document.getElementById('passphrase').value.trim();
        
        let output = '<strong>âœ… Seed Data - Fire Rotasjoner:</strong><br><br>';
        
        // Vis rotasjon for hver farge
        const colors = {
            'Ïˆâ‚': { name: 'RÃ¸d (PrimÃ¦r)', color: '#FF6B6B' },
            'Ïˆâ‚‚': { name: 'BlÃ¥ (SekundÃ¦r)', color: '#4ECDC4' },
            'Ïˆâ‚ƒ': { name: 'GrÃ¸nn (TertiÃ¦r)', color: '#45B7D1' },
            'Ïˆâ‚„': { name: 'Gul (KvaternÃ¦r)', color: '#FFE66D' }
        };
        
        Object.keys(vertexRotations).forEach(vertex => {
            const rot = vertexRotations[vertex];
            const rotX = (rot.x * 180/Math.PI).toFixed(1);
            const rotY = (rot.y * 180/Math.PI).toFixed(1);
            const rotZ = (rot.z * 180/Math.PI).toFixed(1);
            
            output += `<strong style="color: ${colors[vertex].color}">${vertex} (${colors[vertex].name}):</strong><br>`;
            output += `X: ${rotX}Â°, Y: ${rotY}Â°, Z: ${rotZ}Â°<br><br>`;
        });
        
        output += `<strong>Passfrase:</strong> ${passphrase || '(ingen)'}<br><br>`;
        output += `<em style="color: #4ECDC4;">ğŸ” Fire unike rotasjoner klar for hashing!</em>`;
        
        document.getElementById('seed-output').innerHTML = output;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        // Oppdater koordinatene kontinuerlig
        if (tetrahedron) {
            const rotation = tetrahedron.rotation;
            document.getElementById('rot-x').textContent = (rotation.x * 180 / Math.PI).toFixed(1) + 'Â°';
            document.getElementById('rot-y').textContent = (rotation.y * 180 / Math.PI).toFixed(1) + 'Â°';
            document.getElementById('rot-z').textContent = (rotation.z * 180 / Math.PI).toFixed(1) + 'Â°';
        }
        
        renderer.render(scene, camera);
    }
    
    // Start app
    init();
</script>
```

</body>
</html>
