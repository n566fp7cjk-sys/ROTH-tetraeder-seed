<!DOCTYPE html>
<html>
<head>
    <title>RoTH Tetraeder Seed Ceremony</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; }
        #ui { 
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0,0,0,0.9); color: white; padding: 25px; 
            border-radius: 15px; border: 1px solid rgba(255,255,255,0.1);
            max-width: 350px;
        }
        .vertex { 
            padding: 10px; margin: 8px 0; border-radius: 8px; 
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        .vertex:hover { background: rgba(255,255,255,0.1); transform: translateX(5px); }
        .vertex.selected { background: rgba(255,255,255,0.15); border-color: currentColor; font-weight: bold; }
        .vertex-œà‚ÇÅ { color: #FF6B6B; }
        .vertex-œà‚ÇÇ { color: #4ECDC4; }
        .vertex-œà‚ÇÉ { color: #45B7D1; }
        .vertex-œà‚ÇÑ { color: #FFE66D; }
        #coordinates { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin: 15px 0; font-family: monospace; }
        #passphrase { width: 100%; padding: 12px; margin: 10px 0; border: none; border-radius: 8px; background: rgba(255,255,255,0.1); color: white; }
        button { width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; }
        button:hover { background: #764ba2; }
        #seed-output { margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; word-break: break-all; font-family: monospace; font-size: 11px; }
        .loading { opacity: 0.6; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <h2>üî∫ RoTH Seed Ceremony</h2>
        
        <div style="margin-bottom: 20px;">
            <strong>Velg ditt hj√∏rne:</strong>
            <div class="vertex vertex-œà‚ÇÅ" onclick="selectVertex('œà‚ÇÅ')">œà‚ÇÅ: R√∏d (Prim√¶r)</div>
            <div class="vertex vertex-œà‚ÇÇ" onclick="selectVertex('œà‚ÇÇ')">œà‚ÇÇ: Bl√• (Sekund√¶r)</div>
            <div class="vertex vertex-œà‚ÇÉ" onclick="selectVertex('œà‚ÇÉ')">œà‚ÇÉ: Gr√∏nn (Terti√¶r)</div>
            <div class="vertex vertex-œà‚ÇÑ" onclick="selectVertex('œà‚ÇÑ')">œà‚ÇÑ: Gul (Kvatern√¶r)</div>
        </div>
        
        <div id="coordinates">
            <div>üìç <strong>Posisjon:</strong> <span id="pos-x">0.0</span>, <span id="pos-y">0.0</span>, <span id="pos-z">0.0</span></div>
            <div>üîÑ <strong>Rotasjon:</strong> <span id="rot-x">0.0¬∞</span>, <span id="rot-y">0.0¬∞</span>, <span id="rot-z">0.0¬∞</span></div>
            <div>üéØ <strong>Hj√∏rne:</strong> <span id="current-vertex">œà‚ÇÅ</span></div>
        </div>
        
        <input type="text" id="passphrase" placeholder="Skriv din passfrase her...">
        <button onclick="generateSeed()" id="generate-btn">üé≤ Generer Seed</button>
        
        <div id="seed-output">
            <!-- Seed vil vises her -->
        </div>
    </div>

    <script>
        // RoTH v6.2 JavaScript Implementasjon
        class RoTH {
            constructor() {
                this.STATE_WORDS = 16;
                this.ROUNDS = 30;
                this.RC = this.generateRoundConstants();
            }

            generateRoundConstants() {
                return [
                    0x1B9D7B6A7F8E2D1Cn, 0x11C2F1E8B4A37095n, 0xA47F9C3D2E1B5F68n, 0x73E8D9C4B5A29107n,
                    0x5F2A8B6C7D3E4F19n, 0x4B6D8E2F1A3C5D70n, 0x39F1A2B3C4D5E6F7n, 0x28C4D5E6F7A8B9C0n,
                    0x17F3E4D5C6B7A890n, 0x06A1B2C3D4E5F678n, 0x95F0E1D2C3B4A567n, 0x84D3C2B1A0987654n,
                    0x73B2A19088776655n, 0x62A1908877665544n, 0x5190877665544332n, 0x4087766554433221n,
                    0x3F87665544332211n, 0x2E76554433221100n, 0x1D654433221100FFn, 0x0C5433221100FFEEn,
                    0xFB43221100FFEEDDn, 0xEA321100FFEEDDCCn, 0xD92100FFEEDDCCBBn, 0xC810FFEEDDCCBAAn,
                    0xB7FFEEDDCCBBAA99n, 0xA6EEDDCCBBAA9988n, 0x95DDCCBBAA998877n, 0x84CCBBAA99887766n,
                    0x73BBAA9988776655n, 0x62AA998877665544n
                ];
            }

            ROTL64(x, n) {
                n = BigInt(n);
                return ((x << n) | (x >> (64n - n))) & 0xFFFFFFFFFFFFFFFFn;
            }

            theta(s) {
                let c = [
                    s[0]^s[1]^s[2]^s[3],   s[4]^s[5]^s[6]^s[7],
                    s[8]^s[9]^s[10]^s[11], s[12]^s[13]^s[14]^s[15]
                ];
                
                let t = c[0] ^ this.ROTL64(c[2], 1);
                
                for (let i = 0; i < 16; i += 4) {
                    s[i+0] ^= t ^ this.ROTL64(c[(i/4+1)%4], 1);
                    s[i+1] ^= t ^ this.ROTL64(c[(i/4+2)%4], 1);
                    s[i+2] ^= t ^ this.ROTL64(c[(i/4+3)%4], 1);
                    s[i+3] ^= t ^ this.ROTL64(c[(i/4+0)%4], 1);
                }
            }

            pi_rho(s, r) {
                let tmp = new Array(16);
                const offset = (r * 7) % 16;
                
                for (let i = 0; i < 16; ++i) {
                    let src = (i + offset + Math.floor(i / 4)) & 15;
                    tmp[i] = this.ROTL64(s[src], (i * 11 + r) & 63);
                }
                
                for (let i = 0; i < 16; ++i) s[i] = tmp[i];
            }

            chi(s) {
                for (let i = 0; i < 16; i += 4) {
                    let a = s[i], b = s[i+1], c = s[i+2], d = s[i+3];
                    s[i]   ^= (~b & c) ^ this.ROTL64(a, 7);
                    s[i+1] ^= (~c & d) ^ this.ROTL64(b, 11);
                    s[i+2] ^= (~d & a) ^ this.ROTL64(c, 19);
                    s[i+3] ^= (~a & b) ^ this.ROTL64(d, 31);
                }
            }

            iota(s, r) {
                s[0] ^= this.RC[r];
            }

            round(s, r) {
                this.theta(s);
                this.pi_rho(s, r);
                this.chi(s);
                this.iota(s, r);
            }

            hash(input) {
                // Initialiser state med nuller
                let state = Array(16).fill(0n);
                
                // Absorber input
                for (let i = 0; i < Math.min(input.length, 8); i++) {
                    state[i] ^= BigInt(input[i]);
                }
                
                // Kj√∏r runder
                for (let r = 0; r < this.ROUNDS; r++) {
                    this.round(state, r);
                }
                
                // Ekstraher output
                let output = [];
                for (let i = 0; i < 4; i++) {
                    let val = state[i];
                    for (let j = 0; j < 8; j++) {
                        output.push(Number((val >> BigInt(j * 8)) & 0xFFn));
                    }
                }
                
                return new Uint8Array(output);
            }
        }

        // Three.js applikasjon
        let scene, camera, renderer, controls, tetrahedron;
        let selectedVertex = 'œà‚ÇÅ';
        let vertexSpheres = [];
        let roth = new RoTH();
        
     function init() {
    // Three.js setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);
    
    // Kamera kontroller (behold for zoom/pan)
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    camera.position.z = 8;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    
    createTetrahedron();
    setupTetrahedronMovement(); // ‚Üê NY: Gj√∏r tetraederet interaktivt
    animate();
    updateCoordinates();
    selectVertex('œà‚ÇÅ');
}
        
        function createTetrahedron() {
            // Tetrahedron
            const geometry = new THREE.TetrahedronGeometry(2.5);
            const material = new THREE.MeshPhongMaterial({
                color: 0x444444, transparent: true, opacity: 0.2
            });
            tetrahedron = new THREE.Mesh(geometry, material);
            scene.add(tetrahedron);
            
            // Vertex spheres
            const sphereGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const vertices = [
                { pos: [2.5, 2.5, 2.5], color: 0xFF6B6B, id: 'œà‚ÇÅ' },
                { pos: [2.5, -2.5, -2.5], color: 0x4ECDC4, id: 'œà‚ÇÇ' },
                { pos: [-2.5, 2.5, -2.5], color: 0x45B7D1, id: 'œà‚ÇÉ' },
                { pos: [-2.5, -2.5, 2.5], color: 0xFFE66D, id: 'œà‚ÇÑ' }
            ];
            
            vertices.forEach(vertex => {
                const material = new THREE.MeshPhongMaterial({ 
                    color: vertex.color, emissive: vertex.color, emissiveIntensity: 0.3
                });
                const sphere = new THREE.Mesh(sphereGeometry, material);
                sphere.position.set(...vertex.pos);
                sphere.userData = { id: vertex.id };
                vertexSpheres.push(sphere);
                scene.add(sphere);
            });
            
            // Wireframe
            const wireframe = new THREE.WireframeGeometry(geometry);
            const line = new THREE.LineSegments(wireframe);
            line.material.color.set(0x888888);
            line.material.transparent = true;
            line.material.opacity = 0.3;
            tetrahedron.add(line);
        }

// Legg til etter createTetrahedron() funksjonen:

function setupTetrahedronMovement() {
    // Gj√∏r tetraederet selv flyttbart og roterbart
    tetrahedron.position.set(0, 0, 0);
    
    // Legg til event listeners for dragging (forenklet)
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    
    renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    renderer.domElement.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const deltaMove = {
            x: e.clientX - previousMousePosition.x,
            y: e.clientY - previousMousePosition.y
        };
        
        // Roter tetraederet basert p√• musebevegelse
        tetrahedron.rotation.y += deltaMove.x * 0.01;
        tetrahedron.rotation.x += deltaMove.y * 0.01;
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
    });
    
    renderer.domElement.addEventListener('mouseleave', () => {
        isDragging = false;
    });
    
    // Touch support for mobil
    renderer.domElement.addEventListener('touchstart', (e) => {
        isDragging = true;
        previousMousePosition = { 
            x: e.touches[0].clientX, 
            y: e.touches[0].clientY 
        };
        e.preventDefault();
    });
    
    renderer.domElement.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        
        const deltaMove = {
            x: e.touches[0].clientX - previousMousePosition.x,
            y: e.touches[0].clientY - previousMousePosition.y
        };
        
        tetrahedron.rotation.y += deltaMove.x * 0.01;
        tetrahedron.rotation.x += deltaMove.y * 0.01;
        
        previousMousePosition = { 
            x: e.touches[0].clientX, 
            y: e.touches[0].clientY 
        };
        e.preventDefault();
    });
    
    renderer.domElement.addEventListener('touchend', () => {
        isDragging = false;
    });
}
        
        function selectVertex(vertexId) {
            selectedVertex = vertexId;
            
            // Update UI
            document.querySelectorAll('.vertex').forEach(el => {
                el.classList.toggle('selected', el.textContent.includes(vertexId));
            });
            document.getElementById('current-vertex').textContent = vertexId;
            
            // Visual feedback
            vertexSpheres.forEach(sphere => {
                const isSelected = sphere.userData.id === vertexId;
                sphere.material.emissiveIntensity = isSelected ? 0.8 : 0.3;
                sphere.scale.setScalar(isSelected ? 1.4 : 1.0);
            });
        }
        
    function updateCoordinates() {
    // Bruk tetraederets faktiske posisjon og rotasjon, ikke controls
    const position = tetrahedron.position;
    const rotation = tetrahedron.rotation;
    
    document.getElementById('pos-x').textContent = position.x.toFixed(2);
    document.getElementById('pos-y').textContent = position.y.toFixed(2);
    document.getElementById('pos-z').textContent = position.z.toFixed(2);
    
    document.getElementById('rot-x').textContent = (rotation.x * 180 / Math.PI).toFixed(1) + '¬∞';
    document.getElementById('rot-y').textContent = (rotation.y * 180 / Math.PI).toFixed(1) + '¬∞';
    document.getElementById('rot-z').textContent = (rotation.z * 180 / Math.PI).toFixed(1) + '¬∞';
    
    requestAnimationFrame(updateCoordinates);
}

function generateSeed() {
    const passphrase = document.getElementById('passphrase').value.trim();
    // Bruk tetraederets FAKTISKE posisjon og rotasjon
    const position = tetrahedron.position;
    const rotation = tetrahedron.rotation;
    const btn = document.getElementById('generate-btn');
    
    if (!passphrase) {
        document.getElementById('seed-output').innerHTML = '‚ö†Ô∏è Vennligst skriv inn en passfrase';
        return;
    }
    
    // Show loading
    btn.innerHTML = '‚è≥ Genererer...';
    btn.classList.add('loading');
    
    setTimeout(() => {
        try {
            // Forbered input data med ekte tetraeder-posisjon
            const inputData = prepareInputData(position, rotation, selectedVertex, passphrase);
            
            // Generer hash med RoTH
            const seedBytes = roth.hash(inputData.rawBytes);
            const seedHex = bytesToHex(seedBytes);
            
            displayResult(inputData, seedHex, seedBytes);
            
        } catch (error) {
            document.getElementById('seed-output').innerHTML = 
                '‚ùå Feil under hash-generering: ' + error.message;
            console.error('Feil detaljer:', error);
        } finally {
            // Reset button
            btn.innerHTML = 'üé≤ Generer Seed';
            btn.classList.remove('loading');
        }
    }, 100);
}
        
        function prepareInputData(position, rotation, vertex, passphrase) {
            const encoder = new TextEncoder();
            
            // Konverter alle data til bytes
            const posBytes = new Float32Array([position.x, position.y, position.z]);
            const rotBytes = new Float32Array([rotation.x, rotation.y, rotation.z]);
            const vertexByte = vertexToByte(vertex);
            const passBytes = encoder.encode(passphrase);
            
            // Kombiner alle bytes
            const combined = new Uint8Array(
                posBytes.byteLength + 
                rotBytes.byteLength + 
                1 + 
                passBytes.length
            );
            
            let offset = 0;
            combined.set(new Uint8Array(posBytes.buffer), offset);
            offset += posBytes.byteLength;
            
            combined.set(new Uint8Array(rotBytes.buffer), offset);
            offset += rotBytes.byteLength;
            
            combined.set([vertexByte], offset);
            offset += 1;
            
            combined.set(passBytes, offset);
            
            // Returner b√•de r√•data og inputData for display
            return {
                rawBytes: combined,
                position: [position.x, position.y, position.z],
                rotation: [rotation.x, rotation.y, rotation.z],
                vertex: vertex,
                passphrase: passphrase
            };
        }
        
        function vertexToByte(vertexId) {
            const mapping = { 'œà‚ÇÅ': 0x10, 'œà‚ÇÇ': 0x20, 'œà‚ÇÉ': 0x30, 'œà‚ÇÑ': 0x40 };
            return mapping[vertexId] || 0x10;
        }
        
        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => 
                b.toString(16).padStart(2, '0')
            ).join('');
        }
        
        function displayResult(inputData, seedHex, seedBytes) {
            const seedB64 = btoa(String.fromCharCode(...seedBytes));
            
            document.getElementById('seed-output').innerHTML = `
                <div style="margin-bottom: 10px;"><strong>üéâ Ekte RoTH Seed!</strong></div>
                <div style="font-size: 10px; opacity: 0.8; margin-bottom: 10px;">
                    üìç Posisjon: ${inputData.position.map(p => p.toFixed(2)).join(', ')}<br>
                    üîÑ Rotasjon: ${inputData.rotation.map(r => (r * 180/Math.PI).toFixed(1) + '¬∞').join(', ')}<br>
                    üéØ Hj√∏rne: ${inputData.vertex}<br>
                    üîë Passfrase: ${inputData.passphrase}
                </div>
                <strong>RoTH Hash (Hex):</strong><br>
                <code style="font-size: 9px;">${seedHex}</code><br><br>
                <strong>Base64:</strong><br>
                <code style="font-size: 9px;">${seedB64}</code><br><br>
                <div style="font-size: 10px; color: #4ECDC4;">
                    ‚úÖ <strong>Dette er en ekte RoTH v6.2 hash!</strong>
                </div>
            `;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Start app
        init();
    </script>
</body>
</html>
